name: Security Scan

on:
  push:
    branches: [main, develop]
  pull_request:
    branches: [main, develop]
  schedule:
    # Run security scan daily at 2 AM UTC
    - cron: '0 2 * * *'

jobs:
  dependency-scan:
    runs-on: ubuntu-latest
    steps:
      - name: Checkout
        uses: actions/checkout@v4

      - name: Setup pnpm
        uses: pnpm/action-setup@v4
        with:
          version: latest

      - name: Install Dependencies
        run: pnpm install

      - name: Run Security Audit
        run: pnpm audit --audit-level moderate
        continue-on-error: true

      - name: Check for known vulnerabilities
        run: |
          # Check for high/critical vulnerabilities
          if pnpm audit --audit-level high >/dev/null 2>&1; then
            echo "‚úÖ No high or critical vulnerabilities found"
          else
            echo "‚ö†Ô∏è High or critical vulnerabilities detected"
            pnpm audit --audit-level high || true
            exit 1
          fi

  secret-scan:
    runs-on: ubuntu-latest
    steps:
      - name: Checkout
        uses: actions/checkout@v4

      - name: Scan for secrets
        uses: actions/github-script@v7
        with:
          script: |
            const fs = require('fs');
            const path = require('path');
            const { execSync } = require('child_process');

            // Patterns to detect potential secrets
            const secretPatterns = [
              { name: 'API Key', pattern: /api[_-]?key\s*[:=]\s*['"]\w{20,}['"]/ },
              { name: 'Password', pattern: /password\s*[:=]\s*['"]\w{8,}['"]/ },
              { name: 'Secret', pattern: /secret\s*[:=]\s*['"]\w{20,}['"]/ },
              { name: 'Token', pattern: /token\s*[:=]\s*['"]\w{20,}['"]/ },
              { name: 'Private Key', pattern: /-----BEGIN\s+(RSA\s+)?PRIVATE\s+KEY-----/ },
              { name: 'JWT Token', pattern: /eyJ[A-Za-z0-9-_=]+\.[A-Za-z0-9-_=]+\.?[A-Za-z0-9-_.+/=]*/ }
            ];

            const excludePatterns = [
              /\.git\//,
              /node_modules\//,
              /\.pnpm\//,
              /dist\//,
              /build\//,
              /coverage\//,
              /keys\//,
              /__tests__\//,
              /\.test\./
            ];

            function scanDirectory(dir) {
              const items = fs.readdirSync(dir);
              let findings = [];
              
              for (const item of items) {
                const fullPath = path.join(dir, item);
                const relativePath = path.relative('.', fullPath);
                
                // Skip excluded directories
                if (excludePatterns.some(pattern => pattern.test(relativePath))) {
                  continue;
                }
                
                const stat = fs.statSync(fullPath);
                
                if (stat.isDirectory()) {
                  findings = findings.concat(scanDirectory(fullPath));
                } else if (stat.isFile()) {
                  try {
                    const content = fs.readFileSync(fullPath, 'utf8');
                    
                    for (const { name, pattern } of secretPatterns) {
                      const matches = content.match(pattern);
                      if (matches) {
                        findings.push({
                          file: relativePath,
                          type: name,
                          line: content.substring(0, content.indexOf(matches[0])).split('\n').length
                        });
                      }
                    }
                  } catch (error) {
                    // Skip binary files or files that can't be read
                  }
                }
              }
              
              return findings;
            }

            const findings = scanDirectory('.');

            if (findings.length > 0) {
              console.log('üö® Potential secrets detected:');
              for (const finding of findings) {
                console.log(`  ${finding.file}:${finding.line} - ${finding.type}`);
              }
              core.setFailed(`Found ${findings.length} potential secret(s). Please review and remove any hardcoded secrets.`);
            } else {
              console.log('‚úÖ No potential secrets detected');
            }

  openbadges-security:
    runs-on: ubuntu-latest
    steps:
      - name: Checkout
        uses: actions/checkout@v4

      - name: OpenBadges Security Check
        uses: actions/github-script@v7
        with:
          script: |
            const fs = require('fs');
            const path = require('path');

            // OpenBadges-specific security checks
            const securityChecks = [
              {
                name: 'Cryptographic Key Management',
                check: (content) => {
                  // Check for hardcoded cryptographic keys
                  return !/-----BEGIN\s+(RSA\s+)?PRIVATE\s+KEY-----/.test(content) ||
                         content.includes('process.env') || content.includes('config');
                }
              },
              {
                name: 'Badge Verification Security',
                check: (content) => {
                  // Ensure badge verification includes proper signature validation
                  if (content.includes('verifyBadge') || content.includes('validateBadge')) {
                    return content.includes('signature') && content.includes('verify');
                  }
                  return true;
                }
              },
              {
                name: 'User Input Validation',
                check: (content) => {
                  // Check for proper input validation in API endpoints
                  if (content.includes('app.post') || content.includes('app.put')) {
                    return content.includes('validate') || content.includes('schema');
                  }
                  return true;
                }
              }
            ];

            function scanForSecurity(dir) {
              const items = fs.readdirSync(dir);
              let issues = [];
              
              for (const item of items) {
                const fullPath = path.join(dir, item);
                const relativePath = path.relative('.', fullPath);
                
                if (relativePath.includes('node_modules') || relativePath.includes('.git')) {
                  continue;
                }
                
                const stat = fs.statSync(fullPath);
                
                if (stat.isDirectory()) {
                  issues = issues.concat(scanForSecurity(fullPath));
                } else if (stat.isFile() && (fullPath.endsWith('.ts') || fullPath.endsWith('.js'))) {
                  try {
                    const content = fs.readFileSync(fullPath, 'utf8');
                    
                    for (const { name, check } of securityChecks) {
                      if (!check(content)) {
                        issues.push({
                          file: relativePath,
                          issue: name
                        });
                      }
                    }
                  } catch (error) {
                    // Skip files that can't be read
                  }
                }
              }
              
              return issues;
            }

            const issues = scanForSecurity('.');

            if (issues.length > 0) {
              console.log('‚ö†Ô∏è OpenBadges security issues detected:');
              for (const issue of issues) {
                console.log(`  ${issue.file} - ${issue.issue}`);
              }
              // Don't fail the build, but warn about potential issues
              console.log('Please review these potential security concerns.');
            } else {
              console.log('‚úÖ No OpenBadges security issues detected');
            }
